
**Crack Code** is a cross-platform CLI security analysis tool that uses AI to audit a local codebase and identify vulnerabilities, insecure patterns, architectural weaknesses, secrets exposure, injection risks, dependency issues, and logic flaws. The system is strictly non-destructive: it never edits source files. Instead, it produces structured findings, remediation guidance, and ready-to-use AI prompts that developers can apply manually.

The tool is designed for zero-friction adoption. It can run directly via `npx crack-code@latest` or `bunx crack-code@latest`, with optional global installation using npm or bun. After setup, users invoke it as `crack-code` or `crack-code .` to analyze the current repository. This positions Crack Code as a developer-first CLI aligned with existing workflows rather than a separate platform or IDE.

On first run, the system launches an interactive TUI configuration wizard that collects identity preferences, AI provider selection, API credentials or local endpoints, and default model selection based on provider-reported tool-calling compatibility. It optionally enables web search through MCP providers such as Brave, Serper, or Tavily. Configuration is stored locally and remains editable, allowing users to switch providers, models, or MCP setups without reinstalling.

After configuration, the CLI presents a structured dashboard containing ASCII branding, version, host identity, repository context, Git state, and command guidance. Users interact through commands such as help, configuration, tool management, MCP setup, and file targeting. The environment functions as a persistent AI auditing workspace rather than a one-off scanner.

Operationally, Crack Code combines static inspection and contextual AI reasoning. It scans directories, parses files, and builds a semantic understanding of the codebase before generating results. Findings are structured and actionable: severity classification, vulnerability category, explanation, impacted files, remediation strategy, and an AI prompt that can be reused to implement the fix. This design ensures developers retain control over code changes while benefiting from automated analysis.

The runtime includes a default internal toolset that enables the AI agent to navigate repositories and gather context: directory browsing, file discovery, file inspection, optional web search, and MCP invocation. The system supports user-defined tools under strict constraints including permission gating, schema definition, sandboxed execution, and audit logging. MCP integration is native, with baseline servers preconfigured and extensible for future additions.

Architecturally, the tool is modular and provider-agnostic. It supports both remote LLM APIs and local models through Ollama, allowing seamless switching without redesigning workflows. An agent orchestration layer connects filesystem tools, AI providers, and MCP services. Static analysis and retrieval pipelines feed a vulnerability analysis engine, which then produces structured outputs and remediation prompts rendered in the TUI.

The overall design prioritizes extensibility, deterministic scanning workflows, and secure execution boundaries. It is intended to scale from small repositories to large monorepos, operate across different AI ecosystems, and function as a reliable security companion within developer toolchains rather than a replacement for manual review.
